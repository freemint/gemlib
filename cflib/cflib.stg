@database "CF-Lib"
@author "Christian Felsch"
@$VER: PL 12
@subject "Programmieren/C"
@options "+zz-s"

## ##############################################################################
@node "Titel" "CF-Lib"
@{U}Titel                                                               CF-Lib@{0}

   Einleitung

   Entwicklungsgeschichte

   Variablen

   Alerts      App            Asciitab       Colorpop       Comm

   Cookie      Debug          Dragdrop       File           Filesel

   Fontsel     Form_do        Globals        Magx           Mdial

   Menu        Misc           Nkcc           Objc           Popup

   Scrap       Userdef        Vdi            Wdial

   @{"Tips zur RSC-Gestaltung" link "RSC-Gestaltung"}

   Programmliste

@endnode

## ##############################################################################
@node "Einleitung" "CF-Lib: Einleitung"
@{U}Einleitung                                                          CF-Lib@{0}

Im Laufe meiner C-ProgrammierttÑtigkeit auf dem Atari habe ich
verschiedene Bibiliotheken benutzt. qed nutzte frÅher die MyDials
von Olaf Meisiek fÅr die Dialog-Darstellung. In Programmen, die
mit GNU-C programmiert sind (z.B. TosWin2), konnte ich die MyDials
nicht benutzen, da es mir nicht mîglich war, die doch etwas
unÅbersichlichen Quellen auf GNU umzusetzen.
Da die MyDials einige SchwÑchen ausweisen (z.B. haben sie mit prop.
SystemzeichensÑtzen arge Probleme), kam die Idee, eine gÑnzlich
neue Bibiliothek zu schaffen. Herausgekommen ist eine Lib, die sich
in folgenden wesentlichen Punkten von den MyDials unterscheidet:

    ˘ Nutzung der neuen MagiC-Objekte in Dialogen. Falls MagiC nicht
      aktiv ist, werden diese Objekte nahezu identisch emuliert.

    ˘ Portabel programmiert, so daû die Lib sowohl mit PureC als auch
      mit GNU C nutzbar ist.

    ˘ Die Lib kann sowohl mit den frei verfÅgbaren MiNT-Lib / GEM-Lib
      sowie den Pure-Bibliotheken / MT_AES verwendet werden.

Ansonsten stellt die Lib ein Sammelsurium von allen mîglichen Routinen
dar, die man immer wieder benîtigt. Zentrale FunktionalitÑt dÅrften die
Dialogverwaltung sein, die unter Systemen ohne MagiC dessen Objekte
und deren Bedienung (Stichwort Shortcuts) emuliert sowie die Bereit-
stellung von Dialogen und @{Alerts ignore} in Fenster.

Die CF-Lib wird als Freeware mit allen Quelltexten vertrieben.
Jeder kann sie benutzen und fÅr seine Anwendungen verÑndern.

SelbstverstÑndlich sind in der Lib noch jede Menge Fehler enthalten,
die darauf warten, entdeckt zu werden :-)

Christian Felsch
Maintal, im September 2000


PS: Hier der Åbliche Hinweis fÅr die Juristen :-)

  Die Haftung fÅr unmittelbare und mittelbare SchÑden, FolgeschÑden und
  DrittschÑden durch die Benutzung der Bibliothek sind ausgeschlossen.
  FÅr die VollstÑndigkeit und Richtigkeit der gemachten Angaben wird
  keinerlei GewÑhr Åbernommen.

@endnode

@pnode "Christian Felsch"
Kontaktaufnahme:

Christian Felsch
Adalbert-Stifter-Str 33
63477 Maintal

email: C.Felsch@gmx.de
       Christian Felsch @ HH

@endnode

## ##############################################################################
@node "Entwicklungsgeschichte" "CF-Lib: Entwicklungsgeschichte"
@{U}Entwicklungsgeschichte                                              CF-Lib@{0}

 PL 12 vom 09.09.00

    extobfix.prg
    Lief aufgrund eines Bug in der MiNT-Lib 49cf nicht korrekt mit MagiC/TOS.
        
    popup.c
    Event-Handling von cf_menu_popup() Åberarbeitet. Nun funktioniert
    es mit beiden Maustasten korrekt.
    
    misc.c
    grect_to_array() und array_to_grect() neu, fÅr den Fall, daû nicht
    die GNU GEM-Lib benutzt wird. [HA]

    file.c
    split_extension() neue Funktion zum Trennen von Dateinamen und
    Extension. [HA]
    set_extension() kommt nun auch mit .-Dateien (UNIX) klar. [HA]
            
    colorpop.c
    Farbauswahl-Popup mit bis zu 256 Farben. [HA]
 
    Zum PL 12 hat Heiko Achilles @ DU [HA] einige nÅtzliche Dinge 
    beigesteuert!


 PL 11, 19.09.99

   *
   Quelltext freigegeben!

   userdef.c
   Kleine énderungen am Gruppenrahmen.
   Das Vorhandensein der MagiC-Objekte wird jetzt Åber appl_getinfo(13)
   erfragt, so daû die Lib die Objekte unter N.AES 2.0 nicht mehr emuliert.

   *
   Bisher wurden fehlgeschlagene malloc() nur teilweise beachtet. Jetzt
   wird das zentral Åberwacht und es gibt eine Meldung, wenn kein Speicher
   mehr frei ist.
   Auûerdem sollte es nun keine Probleme mehr mit MP geben.

   mdial.c
   wdial.c
   Unter MagiC kann der Cursor innerhalb eines Editfelds mit der Maus
   positioniert werden.


 PL 10, 24.02.99

   cicon.c
   Korrektur an der Farbicon-Darstellung fÅr die 32bit-int-Version (GNU).
   Nun sollten unter TrueColor keine bunten Radio/Check-Buttons mehr auf-
   treten.

   userdef.c
   Korrektur bei der Ausgabe von disabledten Texten.

   mdial.c
   wdial.c
   Das Edit-Objekt "-1" wird wie "0" behandelt, also, als ob der Dialog
   kein Editfeld hat.

   magx.c
   get_magx_typ() hat Check- und Radio-Buttons nicht korrekt ausgewertet.
   Jetzt wird zwischen MagiC-Buttons mit und ohne Shortcut unterschieden.

   app.c
   Die Abmessungen des Systemfonts (sys_[wh]char und sys_[wh]box) wurde nur
   initialisiert, wenn ein GDOS da war :-((

   mdial.c
   wdial.c
   Neue Funktionen change_mdedit(), change_wdedit().
   Sollte man einmal aufrufen, nachdem man man den Status von Edit-
   feldern in offenen Dialogen geÑndert (z.B. DISABLED) hat, damit
   die Cursor-Verwaltung sich ein neues gÅltiges Editfeld sucht bzw.
   den Cursor korrekt versteckt.

   userdef.c
   Bei fix_menu/popup wurde der alte Objekttyp nicht erhalten, so daû
   get_obtype() falsche Werte lieferte.

   mdial.c
   wdial.c
   Korrekturem am Cursor-Redraw.

   userdef.c
   Neue Funktion fix_popup() als Alternative zu fix_menu(). Es ist mîglich,
   die Trennlinien in dÅnne Linien zu wandeln. Auûerdem nimmt die Funktion
   die Wandlung des Objekttyps von G_STRING in G_SHORTCUT vor, wenn MagiC
   aktiv ist. Wer die neuen Funktionen nicht benîtigt, kann weiterhin
   fix_menu() fÅr die Popusp benutzen.

   objc.c
   Der Typ G_SHORTCUT wird nun korrekt behandelt.
   Auûerdem habe ich ein paar Panik-Alerts in diverse Funktionen eingebaut,
   damit es bei unbekannten Objekttypen nicht mehr zum Crash kommt!
   Falls ihr solche Alerts zu Gesicht bekommt, mich bitte Åber die UmstÑnde
   informieren!

   file.c
   Work-Around fÅr path_exists("X:") unter MagiCPC, da `stat("X:")`
   dort nicht funkt, wenn X: ein WinXFS ist.

   userdef.c
   Bei Titel-Objekten ist die Unterstreichung jetzt so lang, wie das
   Objekt breit ist. Bisher wurde die effektive TextlÑnge benutzt.
   Das Verhalten entspricht jetzt dem von MagiC.
   Das Objekt MX_UNDERLINE2 (öberschrift, kleine Schrift) wurde entfernt.

   alerts.c
   Jetzt sind insgesammt fÅnf Zeilen Text mîglich.

   app.c
   Neue globale Variable gl_planes, die die Anzahl der verfÅgbaren
   Farbebenen enthÑlt.

   mdial.c
   Die mdial-Funktionen arbeiten nicht mehr mit void-Parameter sondern
   mit dem Typ MDIAL, der in cflib.h definiert ist. Somit ist ein
   vernÅftiges Type-Checking mîglich.


 PL 9, 08.11.98
   wdial.c
   Wenn es kein Titel-Objekt in einem Dialog gibt, wurde eine Variable
   nicht initialisiert, so daû der Dialog ggf. nicht korrekt geîffnet
   wurde.

   mdial.c:
   open_mdial() macht direkt nach dem ôffnen des Fensters eine
   Messageschleife, um den Redraw noch auszufÅhren. Dadurch ist der
   Dialog bereits komplett sichtbar, wenn open_mdial() zurÅckkehrt.
   Andere eventuell auflaufende Nachrichten werden Åber den Callback
   herausgereicht.

   form_do.c
   mdial.c
   Es wird verhindert, daû beim ôffnen des Dialogs der Edit-Cursor in einem
   ungÅltigen (DISABLED, HIDETREE, !EDITABLE) Editfeld steht.

   popup.c
   Bei Auswahl eines Popups-Eintrags wird solange gewartet, bis die
   Maustaste wieder losgelassen wird. Es werden also keine Dialog-
   Objekte mehr ausgewÑhlt, die direkt unter dem Popupeintrag liegen.

   *
   Die 'nÅtzlichen' Typen bool, uint, uchar, ulong und ushort entfernt,
   damit es keine Probleme mit anderen Bibliotheken gibt (z.B. C++).
   bool wurde durch int ersetzt.

   alert.c
   Statt der GEM-Icons werden die der MyDials benutzt.

   userdef.c
   In monochrom wird bei Editfeldern nicht mehr OUTLINED gesetzt, die
   Felder haben also keinen Rahmen mehr.

   alert.c
   Es gibt jetzt ein viertes Icon (Nummer 0, "Info").

   popup.c
   Korrektur am Popup-Handling: EintrÑge mÅssen G_STRING, !DISABLED und
   SELECTABLE sein, damit sie wÑhlbar sind.

   mdial.c
   wdial.c
   Zentrierung der Dialoge beim ersten ôffnen korrigiert.

   file.c, fs_case_sens()
   VFAT von MagiCPC behauptet zwar, daû es Groûklein echt unterscheidet,
   was aber gelogen ist -> nun wird HALF_CASE geliefert.

   mdial.c
   form_do.c
   wdial.c
   Wird ein Exit-Button mit Doppelklick ausgelîst, ist Bit15 im
   Exit-Objekt gesetzt.

   inline.rsc
   Ein fehlendes 'static' bei der RSC fÅhrte dazu, daû es bei einer
   Applikation mit eigener Inline-RSC zwei 'rs_trindex' gab, was
   natÅrlich zum Crash fÅhrt.

   userdef.c
   Farbicons (Radio/Check-Buttons) werden nun auch bei mehr als 256
   Farben korrekt gezeichnet.

   filesel.c
   Bei Mehrfachauswahl muû der Callback (open_cb()) jetzt TRUE oder
   FALSE zurÅckgeben. Bei FALSE wird der Callback von select_file()
   nicht mehr aufgerufen.

   mdial.c
   Beim Versuch einen Dialog zu 'backdrop'en gibts jetzt einen Ping.

   fontsel.c
   Beim FontProtokoll wird geprÅft, ob der Fontserver auch wirklich
   da ist. Es gibt immer noch Leute, die in FONTSELECT eine Fontauswahl
   anstatt eines Font-Servers eintragen!

   Nun auch mit PureLib/MT_AES benutzbar.
   Die verschiedenen Libs erkennt man an einem 'm' fÅr MiNT-Lib bzw.
   einen 'p' fÅr PureLibs im PatchLevel.


 PL 8, 31.08.98
   userdef.c
   Gruppenrahmen und öberschrift jetzt in 3D (Dank an Jo Even Skarstein!)

   fontsel.c
   MAGCUFSL wird ignoriert, da dieser xFSL->MagiC-Cookie-Verbieger nicht
   mit der Auswahl im Fenster klar kommt. Der Anwender hat dadurch aber
   keinen Nachteil, weil die MagiC-Auswahl direkt, ohne Umweg Åber den
   xFSL-Cookie benutzt wird!

   popupc.c
   handle_popup() verschiebt das Popup ggf. so, daû es immer komplett
   auf dem Bildschirm ist.

   misc.c
   background-Funktionen Åberarbeitet. Sie clippen jetzt auf den Bildschirm.

   objc.c
   set_obspec() neu
   set_ulong() neu
   tree_state() neu

   popups.c
   cf_menu_popup() hat neuen Parameter
   handle_popup() sucht sich nun G_STRING-EintrÑge, so daû z.B. Farb-
   Auswahlpopups (vorne BOX_CHAR, dahinter String) mîglich sind.

   misc.c
   Neue Funktion get_patchlev()

   fontsel.c
   Schwerer Fehler in do_magx(), der zum Verstellen des Fonts auf der
   phys. WS 1 fÅhrte.

   cookie.c
   Getcookie() der MiNT-Lib wird benutzt.

   file.c
   make_normalpath() liefert das Ergebnis von path_exists()


 PL 7, 12.07.98
   Erste îffnetliche Version.


 PL 6, 01.03.98
 PL 5, 19.02.98
 PL 4, 06.11.97
 PL 3, 22.10.97

@endnode

## ##############################################################################
@node "Variablen" "CF-Lib: Variablen"
@alabel Globals
@{U}Globale Variablen                                                   CF-Lib@{0}

Alle Variablen werden von init_app() gesetzt und auf sie sollte nur lesend
zugegriffen werden.

   #define CFLIB_PATCHLEVEL   EnthÑlt den PatchLevel als String
   char __Ident_cflib[];      Ident-String

   int   gl_apid              Applikations-Nummer
   int   gl_phys_handle       Physikalische WS

   GRECT gl_desk              Grîûe des Desktops

   int   sys_big_id           ID und Hîhe der SystmezeichensÑtze
   int   sys_big_height
   int   sys_big_pts
   int   sys_sml_id
   int   sys_sml_height
   int   sys_sml_pts

   int   sys_wchar            Zeichenbox-Grîûen des groûen Systemzeichensatz
   int   sys_hchar
   int   sys_wbox
   int   sys_hbox

   int   gl_wchar             Zeichenbox-Grîûen von graf_handle()
   int   gl_hchar
   int   gl_wbox
   int   gl_hbox

   int   gl_gdos              Ist 1, falls ein GDOS installiert ist
   int   gl_planes            Anzahl der Farbebenen

   char  gl_appdir[]          Der Pfad, von der das Programm gestartet wurde

   int   gl_gem               EnthÑlt die GEM-Version
   int   gl_mint              Versionsnummer von MiNT oder 0
   int   gl_naes              Versionsnummer von N.AES oder 0
   int   gl_magx              Versionsnummer von MagiC oder 0
   int   gl_nvdi              Versionsnummer von NVDI oder 0
                              Alle Versionsnummern liegen als HEX-Werte
                              vor (z.B. 0x601 -> 6.01)
@endnode

## ##############################################################################
@node "Alerts" "CF-Lib: Alerts"
@{U}Alert-Boxen                                                         CF-Lib@{0}

GrundsÑtzlich dÅrfen Alertboxen maximal fÅnf Zeilen Text († 40 Zeichen)
und drei Buttons († 14 Zeichen) enthalten. Als Icons stehen die vier
bekannten zur VerfÅgung (0: Info, 1: Ausrufezeichen, 2: Warndreieck,
3: Stopschild).
ZusÑtzlich zu den Shortcuts, Default- und UNDO-Button lîsen F1, F2 und F3
MagiC-konform die Buttons 1 bis 3 aus. Als Shortcut wird grundsÑtzlich
das erste Zeichen im Button verwendet.

@alabel do_alert
   int do_alert(int def, int undo, char *str);
      Zeigt eine herkîmmliche (modale) Alert-Box an. Parameter wie beim
      form_alert(), allerdings kann zusÑtzlich ein Button definiert
      werden, der mit UNDO ausgelîst wird.

@alabel do_walert
   int do_walert(int def, int undo, char *str, char *win_title);
      Wie do_alert(), allerdings als app-modaler Fensterdialog.
      FÅr das Fenster kann ein Titel angegeben werden.
      Ein Fenster-Alert verhÑlt sich wie ein MDial, d.h. fÅr den
      korrekten Redraw hintenliegender Fenster muû ein @{Callback link MDIAL_WCB}
      eingeklinkt werden!

@endnode

## ##############################################################################
@node "App" ""CF-Lib: App"
@{U}Applikation                                                         CF-Lib@{0}

Einige nÅtzlichen Funktionen, die jede Applikation benîtigt.

@alabel init_app
   void init_app(char *rsc)
         Meldet die Applikation beim GEM an. Setzt alle globalen
         Variable und schaltet Maus auf 'Pfeil'.
         Wird der Name einer RSC Åbergeben, wird diese geladen.

@alabel exit_gem
   void exit_gem(void)
         Meldet die Applikation beim GEM ab, gibt eine eventuell
         geladene Resource frei.

@alabel exit_app
   void exit_app(int ret)
         Beendet eine Applikation mit dem Returnwert <ret>.
         Ruft dazu exit_gem() und anschlieûend exit(ret) auf.


@alabel hide_mouse
   void hide_mouse(void)
         Schaltet die Maus ab.

@alabel hide_mouse_if_needed
   void hide_mouse_if_needed(GRECT *rect)
         Schaltet Maus aus, wenn sie innerhalb des angegebenen
         Rechtecks liegt.

@alabel show_mouse
   void show_mouse(void)
         Schaltet die Maus an.

@alabel appl_xgetinfo
   int  appl_xgetinfo(int type, int *out1, int *out2, int *out3, int *out4)
         Ruft appl_getinfo() auf, prÅft aber zunÑchst auf dessen
         Vorhandensein.

@endnode

## ##############################################################################
@node "Asciitab" "CF-Lib: Asciitab"
@{U}ASCII-Tabelle                                                       CF-Lib@{0}

Die ASCII-Tabelle stell alle nicht Åber die Tastatur erreichbaren Zeichen
zum EinfÅgen zur VerfÅgung.

@alabel ascii_table
   int ascii_table(int id, int pts);
         Ruft die Tabelle als modalen Dialog auf. öbergeben werden muû
         der Font, der zur Darstellung der Zeichen verwendet werden
         soll. Font-Hîhe in Point!!
         FÅr normalen Systemfont: 1, 10.
         Die Tabelle ist vollstÑndig mit Maus und Tastatur bedienbar:

            ˘ Mit den Cursortasten kann man ein Zeichen auswÑhlen.
            ˘ HOME springt zum ersten, Shift-Home zum letzten Zeichen.
            ˘ Return bzw. Mausklick auf ein Zeichen wÑhlt dieses aus.
            ˘ UNDO lîst den Abbruch-Button aus.

         Die ASCII-Tabelle kann auch in jedem Editfeld durch DrÅcken
         von INSERT aufgerufen werden. So kînnen dort auch Sonder-
         zeichen eingegeben werden, sofern die Maske des Feldes
         diese zulÑût.


@alabel set_asciitable_strings
   void set_asciitable_strings(char *title, char *button)
         éndert öberschrift und Button-Text der Tabelle.

@endnode

## ##############################################################################
@node "Colorpop" "CF-Lib: Colorpop"
@{U}Farb-Popups                                                         CF-Lib@{0}

Mit diesen Funktionen kann ein Farb-Objekt mit bis zu 256 Farben angezeigt
werden und ein dazugehîriges Popup-MenÅ mit einer Farbauswahl angezeigt
werden. Die auswÑhlbare Farbanzahl wird dabei automatisch an die
tatsÑchliche Auflîsung angepasst.

@alabel MAX_COLORPOP
   #define MAX_COLORPOP 10
      Maximale Anzahl darstellbarer Farbfelder in der CF-Lib. Per Default
      auf 10 Felder beschrÑnkt.

@alabel init_colorpop
   int init_colorpop(int maxplanes);
      Initialisiert die Colorpop-Routinen, muû bei Programminit einmal
      aufgerufen werden.
      maxplanes   Maximale Anzahl der benutzten Farb-Planes (1-8)
                  Die Anzahl der tatsÑchlich dargestellten und behandelten
                  Planes hÑngt von der Bildschirmauflîsung ab.

@alabel exit_colorpop
   void exit_colorpop(void);
      Meldet die Colorpop-Routinen ab; sollte vor Beenden des Programms
      einmal aufgerufen werden.

@alabel fix_colorpopobj
   void fix_colorpopobj(OBJECT *tree, int obj, int color);
      Wandelt ein Boxobjekt in ein Farb-Userdef um, mit welchem bis zu
      256 Farben dargestellt werden kînnen. Die Farben kînnen mit
      get_popobjcolor() und set_popobjcolor() erfragt bzw. gesetzt werden.

@alabel get_popobjcolor
   int get_popobjcolor(OBJECT *tree, int obj);
      Aktuelle Farbe eines Farb-Userdefs abfragen

@alabel set_popobjcolor
   void set_popobjcolor(OBJECT *tree, int obj, int color);
      Farbe eines Farb-Userdefs setzen. Das
      Objekt muû ggf. nach dem Aufruf von set_popobjcolor() neu gezeichnet
      werden.

@alabel do_colorpop
   int do_colorpop( int x, int y, int item, int planes, int show_noncolor );
      Stellt ein Farb-Popup dar und wertet es aus.
      x,y      Koordinaten; werden ggf. an Bildschirm angepasst, wenn sie
               auûerhalb desselben liegen
      item     aktuelle Farbe; auf diese Farbe beziehen sich die
               Koordinaten
      planes   maximal auswÑhlbare Planes (1-8). Die tatsÑchlich
               dargestellten Planes orientieren sich an der
               Bildschirmauflîsung.
      show_noncolor
               Wird hier ein Wert != 0 Åbergeben, wird im Popup auch ein
               durchgestrichener Eintrag dargestellt, welcher eine
               "Nichtfarbe" reprÑsentiert (z.B. fÅr "keine FarbÑnderung")
               Wird dieser Eintrag ausgewÑhlt, liefert 
               do_colorpop() -2 zurÅck.

@alabel handle_colorpop
   int handle_colorpop( OBJECT *dial, int dial_obj, int mode,
                        int planes, int show_noncolor );
      Hi-Level Farbpopupverwaltung fÅr Dialoge
      dial     der Dialog, in dem das Farb-Popup angeklickt wurde
      dial_obj Nummer des Objekts im Dialog
      mode     Aktion, die ausgefÅhrt werden soll:
               POP_OPEN (1)   Farb-Popup îffnen
               POP_CYCLE (2)  NÑchsten Eintrag selektieren
      planes   maximal auswÑhlbare Planes (1-8). Die tatsÑchlich
               dargestellten Planes orientieren sich an der
               Bildschirmauflîsung.
      show_noncolor
               Wird hier ein Wert != 0 Åbergeben, wird im Popup auch ein
               durchgestrichener Eintrag dargestellt, welcher eine
               "Nichtfarbe" reprÑsentiert (z.B. fÅr "keine FarbÑnderung")
               Wird dieser Eintrag ausgewÑhlt, liefert 
               handle_colorpop() -2 zurÅck.

@endnode

## ##############################################################################
@node "Comm" "CF-Lib: Comm"
@{U}Kommunikation                                                       CF-Lib@{0}

@alabel send_vastart
   void send_vastart(int id, char *str);
         Schickt ein VA_START an die Applikation <id>.

@alabel send_m_special
   void send_m_special(int mode, int app);
         Schickt eine Spezial-Nachricht an den ScreenManager von MagiC.

@alabel send_scchanged
   void send_scchanged(void);
         Verschickt ein SC_CHANGED an alle anderen Applikationen per
         Broardcast. Sollte man verwenden, wenn man das Klemmbrett
         verÑndert hat.

@endnode

## ##############################################################################
@node "Cookie" "CF-Lib: Cookie"
@{U}Cookie-Auslesen                                                     CF-Lib@{0}

@alabel getcookie
   int getcookie(char *cookie, long *value)
         PrÅft auf den angegebenen Cookie.
         Eingabe:
            cookie   Name des zu ÅberprÅfenden Cookies.
         RÅckgabe:
            value    Inhalt des Cookie (falls vorhanden!). Wenn
                     der Inhalt nicht interessiert, kann NULL
                     Åbergeben werden.
         Die Routine liefert 1, wenn der Cookie vorhanden ist, sonst 0.

@endnode

## ##############################################################################
@node "Debug" "CF-Lib: Debug"
@{U}Debugausgaben                                                       CF-Lib@{0}


   typedef enum {null, Con, TCon, Datei, Terminal,
                 Modem1, Modem2, Seriell1, Seriell2, Prn} DEVICETYP;
         Die mîglichen AusgabekanÑle. Bei TCON gehen die Ausgaben
         wie bei Con auf die Console, allerdings wird vorher ÅberprÅft,
         ob T-Con lÑuft.

   int gl_debug
         Zeigt an, ob debug_init() erfolgt ist.

@alabel debug_init
   void debug_init(char *prgName, DEVICETYP dev, char *file);
         Initialisiert das Debugdevice.
         Eingabe:
           prgName  Wird jeder Debug-Meldung vorangestellt.
           dev      Typ des Devices
           file     Wenn dev = Datei, der Dateiname der Log-Datei,
                    sonst NULL.

@alabel debug_exit
   void debug_exit(void)
         Schlieût das Device.

@alabel debug
   void debug(char *FormatString, ...);
         Die eigentliche Ausgabefunktion.
         Parameter so wie bei printf().

@endnode

## ##############################################################################
@node "Dragdrop" "CF-Lib: Dragdrop"
@{U}Drag&Drop Protokoll                                                 CF-Lib@{0}

   #define DD_OK
   #define DD_NAK
   #define DD_EXT
   #define DD_LEN
   #define DD_TIMEOUT
   #define DD_NUMEXTS
   #define DD_EXTSIZE
   #define DD_NAMEMAX
   #define DD_HDRMAX

@autorefoff
   @{U}Funktionen fÅr den Sender:@{0}

@alabel dd_create
   int dd_create(int apid, int winid, int msx, int msy, int kstate,
                 char *exts);
         Legt eine Pipe fÅr D&D an und informiert EmpfÑnger mittels
         AP_DRAGDROP.
            apid        ID der Ziel-App
            winid       ID des Ziel-Fensters (0 fÅr Desktop)
            msx, msy    aktuelle Maus-Position
            kstate      Shift-Status

            exts        32 Byte groûer Puffer, in dem die gÅltigen
                        Extensions des EmpfÑngers geliefert werden
            RÅckgabe    Entweder positives GEMDOS Dateihandle oder:
                           -1 EmpfÑnger schickt DD_NAK
                           -2 Fehler beim appl_write(AP_DRAGDROP)

@alabel dd_stry
   int dd_stry(int fd, char *ext, char *name, long size);
         PrÅft, ob der EmpÑnger einen bestimmten Datentyp akzeptiert.
            fd          Pipe-Handle
            ext         4 Byte Extension
            name        Name der Daten
            size        Anzahl der Bytes, die Åbertragen werden
                        sollen

            RÅckgabe    DD_OK    wird akzeptiert
                        DD_EXT   Extension abgelehnt
                        DD_LEN   LÑnge der Daten abgelehnt
                        DD_NAK   Kommunikation abgebrochen


   @{U}Funktionen fÅr den EmpÑnger:@{0}

@alabel dd_open
   int dd_open(int ddnam, char *ext);
         ôffnet eine Pipe.

            ddnam       Nummer der Pipe (msg[7] vom AP_DRAGDROP)
            ext         Vom EmpfÑnger verstandene Extensions. Jeweils
                        4 Bytes, insgesamt DD_NUMEXT

            RÅckgabe    Entweder ein positives GEMDOS Dateihandle,
                        -1 bei Abruch durch den Sender oder einen
                        negativen GEMDOS-Fehlercode

@alabel dd_rtry
   int dd_rtry(int fd, char *name, char *ext, long *size);
         Einen D&D-Header empfangen.
            fd          Handle der Pipe

            name        Name der Daten, max. DD_NAMEMAX Bytes lang
            ext         Typ der Daten als 4Byte-Extension
            size        Grîûe der Daten

            RÅckgabe    1, wenn O.K.

@alabel dd_reply
   int dd_reply(int fd, int ack);
         Schickt 1-Byte-Antwort an den Sender.
            fd          Handle der Pipe
            ack         Antwort: (DD_OK, DD_NAK, ...)

            RÅckgabe    1, wenn alles OK


   @{U}Funktionen fÅr beide:@{0}

@alabel dd_close
   void dd_close(int fd);
         Schlieût die Åbergeben Pipe wieder.
@autorefon

@endnode

## ##############################################################################
@node "File" "CF-Lib: File"
@{U}Aktionen auf Dateinamen und Pfade                                   CF-Lib@{0}

@alabel file_exists
@alabel path_exists
   int file_exists(char *filename);
   int path_exists(char *pathname);
         PrÅft das Vorhandensein.

@alabel get_path
@alabel set_path
   int get_path(char *path, char drive);
   int set_path(char *path);
         Liefer/Setzt den aktuellen Pfad. (drive = 0 fÅr Defaultdrive)

@alabel split_filename
   void split_filename(char *fullname, char *path, char *name);
         Spaltet einen kompletten Dateipfad in Pfad und Name auf.
         Wenn Pfad oder Name nicht interessieren, kann NULL angegeben
         werden.

@alabel split_extension
   void split_extension(char *fullname, char *name, char *extension);
         Spaltet einen kompletten Dateinamen in Namen und Extender
         (ohne Punkt) auf. Versteckte UNIX-Dateinamen (Dateien, die mit
         einem Punkt am Anfang beginnen), werden berÅcksichtigt.
         Wenn Name oder Extender nicht interessieren, kann NULL angegeben
         werden.

@alabel set_extension
   void set_extension(char *filename, char *new_ext);
         éndert die Datei-Extension in einem Namen.
         Versteckte UNIX-Dateinamen (Dateien, die mit
         einem Punkt am Anfang beginnen), werden berÅcksichtigt.

@alabel make_normalpath
   int make_normalpath(char *path);
         Wandelt Pfad in einen gÅltigen um (ggf. mit unx2dos).
         Liefert das Ergebnis von path_exists(path) zurÅck.

@alabel make_shortpath
   void make_shortpath(char *path, char *shortpath, int maxlen);
         KÅrzt <path> auf <maxlen>. Falls <path> zulang ist, werden
         '..' eingefÅgt.

@alabel fs_long_name
   int fs_long_name(char *filename);
         PrÅft, ob das Dateisystem, auf dem sich <filename> befindet,
         lange Dateinamen kann. 'Lang' bedeutet in diesem Fall mehr als
         8+3 Zeichen auf TOS-Partitionen.

@alabel fs_case_sens
   int fs_case_sens(char *filename);
         PrÅft, ob das Dateisystem, auf dem sich <filename> befindet,
         Groû/Kleinschrift unterscheidet. Ergebnis ist eine drei-wertige
         Logik:
            NO_CASE     Kein Unterschied (TOS-FS)
            HALF_CASE   Kein echter Unterschied. Es kann zwar Groû/Klein
                        benutzt werden, beim Zugriff ist es aber egal
                        (VFAT, Mac HFS)
            FULL_CASE   Echte Unterscheidung (Minix)

@endnode

## ##############################################################################
@node "Filesel" "CF-Lib: Filesel"
@{U}Dateiauswahl                                                        CF-Lib@{0}

@alabel FSEL_CB
   typedef void (* FSEL_CB)(char *path, char *name);
   #define FSCB_NULL

@alabel select_file
   int select_file(char *path, char *name, char *mask, char *title,
                     FSEL_CB open_cb);

      FÅhrt eine Dateiauswahl durch (Einfach- oder Mehrfachauswahl)(*)
      Dabei wird eine ggf. vorhandene Mehrfachauswahl unterstÅtzt,
      d.h. sobald Selectric-Cookie (Selectrics, Freedom, Boxkites)
      oder die MagiC-Dateiauswahl vorhanden sind, ist es mîglich,
      mehrere Dateien mit einem Aufruf auszuwÑhlen.
         <path>      Pfad, auf dem die Auswahl geîffnet wird, oder ""
         <name>      Datei, die vorselektiert wird, oder ""
         <mask>      Dateimaske, bei leerem "" wird *.* benutzt
         <title>     öberschift der Auswahl
         <open_cb>   Wird in <open_cb> eine Routine angegeben, wird
                     eine Mehrfachauswahl durchgefÅhrt, wobei die
                     angegebene Funktion mit jedem ausgewÑhlten
                     Dateinamen einmal aufgerufen wird.

      RÅckgabe:
         1           wenn die Auswahl erfolgreich war
         <path>      AusgewÑhlter Pfad
         <name>      AusgwÑhlte Datei

      Da bei der Mehrfachauswahl der Callback mit jedem Namen
      aufgerufen wird, liefert select_file() zwar TRUE, allerdings
      werden <path> und <name> leer zurÅckgegeben.

@index Selectric
   Anmerkung zu Selectric:
     Bei diesem Protokoll muû man vorher festlegen, wieviele Dateien
     gleichzeitig markiert werden dÅrfen. Derzeit sind mit der CF-Lib
     maximal 10 Dateien mîglich!

@index MagiC-Dateiauswahl
   Anmerkung zu MagiC:
     Falls mit set_mdial_wincb() eine Message-Funktion angemeldet
     wurde, erscheint die Dateiauswahl im Fenster, an sonsten als
     modaler Dialog.
     Bei der MagiC-Dateiauswahl kînnen im Gegensatz zu Selectric
     bei der Mehrfachauswahl beliebig viele Dateien ausgewÑhlt
     werden.
     In die Popups der Auswahl werden folgende Dinge eingestellt:
        Pfad-History   Mit dem Åbergebenen Pfad
        Maske          '*.*' wird immer an <mask> angehÑngt
        Sortierung     Nach Name

@endnode

## ##############################################################################
@node "Fontsel" "CF-Lib: Fontsel"
@index MagiC-Fontauswahl
@{U}Fontauswahl                                                         CF-Lib@{0}

@alabel do_fontsel
   int do_fontsel(int flags, char *title, int *id, int *pts);
         Ruft eine Fontauswahl auf.
         öber verschiedene in <flags> gesetzte Bits kann die Font-
         auswahl konfiguriert werden:

            - Art der Auswahl:
               FS_M_XFSL      öber den xFSL-Cookie (Calvino, HuGo)
               FS_M_FPROT     öber Fontprotokoll (*)
               FS_M_MAGX      öber AES-Calls von MagiC (*)
               FS_M_ALL       Alle o.g. nacheinander, bis ein Modus
                              erfolgreich war.
               Falls mehrere Fontauswahlen im System vorhanden sind,
               werden die drei Mîglichkeiten nach einander geprÅft.
               Also als erstes wird der xFSL-Cookie, dann $FONTSERVER
               und zuletzt MagiC probiert.

            - Sonstiges:
               FS_F_MONO      Statt aller ZeichensÑtze werden nur die
                              Ñquidistanten (monospaced) angeboten.

         Desweiteren wird in <title> die öberschrift fÅr die Font-
         auswahl Åbergeben.
         Im Falle, daû die Auswahl erfolgreich war, wird 1 geliefert
         und die Fontdaten zurÅckgegeben.
         Sollte keine Fontauswahl verfÅgbar sein, wird 0 geliefert
         und <id> und <pts> enthalten -1.

   Anmerkung zu MagiC/xFSL:
     Falls mit set_mdial_wincb() eine Message-Funktion angemeldet
     wurde, erscheint die Fontauswahl im Fenster, an sonsten als
     modaler Dialog.

   Anmerkung zu FS_M_FPROT:
     Beim Fontprotokoll wird in der Environmentvariable 'FONTSERVER'
     ein Programm eingetragen, daû dieses Protokoll beherrscht (z.B.
     der Desktop Thing).
     Der Fontserver teilt den ausgewÑhlten Zeichensatz mit einer
     speziellen Nachricht mit, die auûerhalb von do_fontsel() in der
     globalen Eventschleife der Applikation auflÑuft; do_fontsel()
     liefert in diesem Fall immer FALSE zurÅck. Dieser Modus sollte
     also nur dann benutzt werden, wenn die Applikation diese Nach-
     richt versteht!

@endnode

## ##############################################################################
@node "Form_do" "CF-Lib: Form_do"
@{U}Dialogroutinen                                                      CF-Lib@{0}

@alabel cf_form_do
   int  cf_form_do(OBJECT *tree, int *ed_start);
         form_do()-Ersatz mit Sondertastenauswertung. Das Start-Objekt
         muû als Variable Åbergeben werden, da der cf_form_do() am Ende
         dort das aktuelle Editfeld eintrÑgt.

@alabel simple_dial
   int  simple_dial(OBJECT *tree, int start_edit);
         FÅhrt einen simplen Dialog durch.

@alabel KEY_CB
   typedef int (* KEY_CB )(OBJECT *tree, int edit_obj, int kstate,
                           int *kreturn, int *next_obj);
         Typ der Tasten-Routine fÅr set_formdo_keycb().
         Wenn ein Exit-Objekt simuliert werden soll, muû die Routine
         den Objekt-Index in next_obj eintragen und 0 zurÅckliefern.
         Soll der Tasten-Event nicht auch noch durch die CF-Lib aus-
         gewertet werden, muû kreturn auf 0 gesetzt werden.

@alabel set_formdo_keybd
   KEY_CB set_formdo_keycb(KEY_CB new);
         Klinkt eine Routine in die Tasten-Auswertung des form_do() ein.
         Sie wird bei sÑmtlichen Dialogen (modal/a-modal/u-modal)
         aufgerufen, bevor die CF-Lib den Tasten-Event auswertet.
         Die vorher eingestellte Funktion wird zurÅckgeliefert.

@endnode

## ##############################################################################
@node "Magx" "CF-Lib: Magx"
@{U}MagiC Kontrollfunktionen                                            CF-Lib@{0}

@alabel get_magx_version
   int  get_magx_version(void);
         Liefert die MagiX-Version zurÅck.
         Man kann statt dessen auch die Variable gl_magx verwenden, da
         die Funktion von init_app() aufgerufen wird.

@alabel get_magx_obj
   int  get_magx_obj(OBJECT *tree, int obj);
         PrÅft, ob <obj> ein spezielles MagiC-Objekt ist.
         Folgende Typen werden erkannt (anhand des Status WHITEBAK):

            MX_NOTXOBJ      0     Kein MagiC-Objekt (ohne WHITEBAK)
            MX_UNDERLINE    1     String als öberschrift
            MX_RADIO        2     Radiobutton
            MX_SCRADIO      3     Radiobutton mit Shortcut
            MX_CHECK        4     Checkbutton
            MX_SCCHECK      5     Checkbutton mit Shortcut
            MX_SCEXIT       6     Exitbutton mit Shortcut
            MX_SCSTRING     7     String mit Shortcut
            MX_GROUPBOX     8     Gruppenrahmen
            MX_EDIT3D       9     3D-Editfeld

            MX_GROUPBOX2   10     Gruppenrahmen, kleine Schrift (*)

            MX_UNKNOWN     -1     Unbekanntes MagiC-Objekt

         Die mit (*) markierten Objekte stellen eine Erweiterung der CF-Lib
         dar! (siehe auch Userdef)

@alabel get_magx_shortcut
   int  get_magx_shortcut(OBJECT *tree, int obj, char *c);
         Liefert die Position des Shortcuts eines Buttons zurÅck, oder -1.
         In <c> wird das Shortcut-Zeichen eingetragen.

@endnode

## ##############################################################################
@node "Mdial" "CF-Lib: Mdial"
@{U}Modaler Fensterdialog                                               CF-Lib@{0}

Mit diesen Funktionen sind applikations-modale Fensterdialge mîglich.
WÑhrend der Dialogverarbeitung, steht die Applikation still, es ist
aber mîglich, zu anderen Programmen umzuschalten.
Die Funktionen sind ist re-entrant, d.h. wenn ein Dialoge offen ist,
darf ein weiterer geîffnet werden (z.B. Fenster-Alert).

@alabel MDIAL_WCB
   typedef (* MDIAL_WCB )(int *msg);
         Callback fÅr die Fenster-Events der anderen Fenster. MDial
         hat eine eigene Event-Schleife, die bestimmte WM_-Nachrichten
         (z.B. WM_REDRAW, WM_MOVED) Åber diesen Callback herausreicht,
         damit hinter dem modalen Dialog liegende Fenster der Applikation
         entsprechend reagieren kînnen.
         ACHTUNG: die Routine reicht keine Message weiter, die irgendwelche
         Aktionen in dem Programm auslîsen kînnten, z.B. VA_START usw!!

@alabel set_mdial_wincb
   void set_mdial_wincb(MDIAL_WCB new);
         Meldet die Prozedur fÅr Fensterevents an.
         Dieser Message-Handler wird unter anderem auch bei Datei- und
         Fontauswahl sowie Alerts in Fenstern benutzt.


@alabel open_mdial
   MDIAL *open_mdial(OBJECT *tree, int edit_start);
         Legt einen neuen Dialog an und îffnet das Fenster. ZurÅckgegeben
         wird das Dialog-Handle oder NULL. ZusÑtzlich zum Dialogbaum
         muû das Editfeld angegeben werden, auf dem der Cursor beim
         ôffnen gesetzt werden soll. Existiert kein Editfeld, so it 0
         anzugeben.

@alabel do_mdial
   int do_mdial(MDIAL *mdial);
         Event-Schleife des Dialogs. Kehrt erst, wenn ein Exit-Objekt
         gedrÅckt wurde, mit dessen Index zurÅck.

@alabel close_mdial
   void close_mdial(MDIAL *mdial);
         Schlieût und entfernt Dialog.
         Wenn einen Eventprozedur angemeldet ist, kehrt close_mdial()
         erst zurÅck, wenn alle nach dem Schlieûen des Dialogs
         auflaufenden Message-Events verarbeitet wurden (untenliegende
         Fenster werden also erst noch neu gezeichnet).

@alabel simple_mdial
   int simple_mdial(OBJECT *tree, int edit_start);
         FÅhrt einen modalen Fensterdialog komplett durch.
         Ruft dazu open_mdial(), do_mdial() und close_mdial() nacheinander
         auf und liefert das Exit-Objekt zurÅck.

@alabel redraw_mdobj
   void redraw_mdobj(MDIAL *mdial, int obj);
         Zeichnet ein Objekt im Dialog neu.

@alabel change_mdedit
   void change_mdedit(MDIAL *wd, int new);
         Sollte man einmal aufrufen, nachdem man man den Status von Edit-
         feldern in offenen Dialogen geÑndert (z.B. DISABLED) hat, damit
         die Cursor-Verwaltung sich ein neues gÅltiges Editfeld sucht bzw.
         den Cursor korrekt versteckt.

@endnode

## ##############################################################################
@node "Menu" "CF-Lib: Menu"
@{U}Funktionen fÅr die MenÅleiste                                       CF-Lib@{0}

Verwaltung die MenÅleiste der Applikation.
ACHTUNG: Nicht re-entrant, d.h. jede Applikation nur ein Kreuz, Ñh MenÅ!

@alabel create_menu
   int create_menu(OBJECT *tree)
         Neues MenÅ anlegen und anzeigen.
         Liefer 1, wenn alles OK.

@alabel delete_menu
   void delete_menu(void)
         MenÅ wieder abmelden.

@alabel disabel_menu
@alabel enable_menu
   void disable_menu(void)
   void enable_menu(void)
         MenÅzeile (About und alle Titel bis auf Desk) ab- bzw. an-
         schalten. Die Routinen zÑhlen mit, d.h. man muû genau so oft
         enablen, wie man vorher disabled hat!

@alabel is_menu_key
   int is_menu_key(int kreturn, int kstate, int *title, int *item)
         Wenn es sich bei der Taste um einen MenÅ-Shortcut handelt,
         wird 1 sonst 0 geliefert.

@endnode

## ##############################################################################
@node "Misc" "CF-Lib: Misc"
@{U}Sonstiger Kleinkram                                                 CF-Lib@{0}

@alabel ts2ol
@alabel ol2ts
   long ts2ol(short i1, short i2);
   void ol2ts(long l, short *i1, short *i2);
         "two shorts to one long"
         und
         "one long to two shorts"

@alabel save_background
@alabel restore_background
   void save_background      (GRECT *box, MFDB *buffer);
   void restore_background   (GRECT *box, MFDB *buffer);
         Bildschirmhintergrund puffern.

@alabel malloc_global
   void *malloc_global(long size)
         Alloziert einen global freien Speicherbereich mittels Mxalloc()
         (Modus 35), wenn MiNT (Speicherschutz) lÑuft, sonst mit Malloc().

@alabel get_patchlev
   int get_patchlev(char *id_str, char *pl);
         Ermittelt aus einem Ident-String den Patchlevel. Jede Lib
         sollte einen Ident-String enthalten, der so aussieht:
            $PatchLevel: CF library: 7 $
         Liefert 1, wenn der PL ermittelt werden konnte.

@alabel grect_to_array
@alabel array_to_grect
   int *grect_to_array( GRECT *g, int *pxy );
   void array_to_grect( int *pxy, GRECT *g );
         Wandelt eine AES-Rechteck-Struktur GRECT (x, y, w, h)
         in ein VDI-Koordinaten-Array (x1, y1, x2, y2) um bzw. vice versa.
         Diese Funktionen sind Bestandteil der GNU GEM-Lib; da sie
         in anderen Libs fehlen, werden sie von der CF-Lib bei Bedarf
         nachgebildet.
   
@endnode

## ##############################################################################
@node "Nkcc" "CF-Lib: NKCC"
@{U}Normalized Keycode Converter                                        CF-Lib@{0}

Die CF-Lib enthÑlt einige Funktionen aus der NKCC-Lib von Harald Siegmund.
Das sind im wesentlichen die beiden Funktionen, um Tastencodes zwischen
dem TOS- und dem normalisierten Format zu konvertieren.

   /* NKCC key code flags */
   #define NKF_FUNC     0x8000         /* function          */
   #define NKF_RESVD    0x4000         /* resvd, ignore it! */
   #define NKF_NUM      0x2000         /* numeric pad       */
   #define NKF_CAPS     0x1000         /* CapsLock          */
   #define NKF_ALT      0x0800         /* Alternate         */
   #define NKF_CTRL     0x0400         /* Control           */
   #define NKF_SHIFT    0x0300         /* any Shift key     */
   #define NKF_LSH      0x0200         /* left Shift key    */
   #define NKF_RSH      0x0100         /* right Shift key   */

   /* special key codes for keys performing a function */
   #define NK_INVALID   0x00           /* invalid key code  */
   #define NK_UP        0x01           /* cursor up         */
   #define NK_DOWN      0x02           /* cursor down       */
   #define NK_RIGHT     0x03           /* cursor right      */
   #define NK_LEFT      0x04           /* cursor left       */
   #define NK_M_PGUP    0x05           /* Mac: page up      */
   #define NK_M_PGDOWN  0x06           /* Mac: page down    */
   #define NK_M_END     0x07           /* Mac: end          */
   #define NK_BS        0x08           /* Backspace         */
   #define NK_TAB       0x09           /* Tab               */
   #define NK_ENTER     0x0a           /* Enter             */
   #define NK_INS       0x0b           /* Insert            */
   #define NK_CLRHOME   0x0c           /* Clr/Home          */
   #define NK_RET       0x0d           /* Return            */
   #define NK_HELP      0x0e           /* Help              */
   #define NK_UNDO      0x0f           /* Undo              */
   #define NK_F1        0x10           /* function key #1   */
   #define NK_F2        0x11           /* function key #2   */
   #define NK_F3        0x12           /* function key #3   */
   #define NK_F4        0x13           /* function key #4   */
   #define NK_F5        0x14           /* function key #5   */
   #define NK_F6        0x15           /* function key #6   */
   #define NK_F7        0x16           /* function key #7   */
   #define NK_F8        0x17           /* function key #8   */
   #define NK_F9        0x18           /* function key #9   */
   #define NK_F10       0x19           /* function key #10  */
   #define NK_M_F11     0x1a           /* Mac: func key #11 */
   #define NK_ESC       0x1b           /* Esc               */
   #define NK_M_F12     0x1c           /* Mac: func key #12 */
   #define NK_M_F14     0x1d           /* Mac: func key #14 */
   #define NK_RVD1E     0x1e           /* reserved!         */
   #define NK_DEL       0x1f           /* Delete            */


@alabel nkc_init
   int nkc_init(void);
         Initialisiert die NKCC. Wird nur benîtigt, wenn nkc_tos2n(),
         nkc_n2tos(), norm_to_gem() oder gem_to_norm() benutzt werden
         sollen.

@alabel nkc_tos2n
@alabel nkc_n2tos
   unsigned short nkc_tos2n(long toskey);
   long nkc_n2tos(unsigned short nkcode);
         BIOS-Taste (Bit 0..7 Ascii, Bit 16..23 Scan, Bit 24..31 Kbshift)
         ins normalisierte Format bzw. umgekehrt wandeln.

@alabel gem_to_norm
@alabel norm_to_gem
   unsigned short gem_to_norm(int ks, int kr);
   void norm_to_gem(unsigned int norm, int *ks, int *kr);
         Wandelt GEM-Taste (z.B. vom evnt_multi) in normalisierten Code
         um.


@alabel nkc_toupper
@alabel nkc_tolower
   unsigned char nkc_toupper(unsigned char chr);
   unsigned char nkc_tolower(unsigned char chr);
         Einzelnes Zeichen in Groû- bzw. Kleinbuchstaben wandeln.
         Nationale Sonderzeichen werden korrekt gewandelt.

@alabel str_toupper
@alabel str_tolower
   void str_toupper(char *str);
   void str_tolower(char *str);
         Zeichenkette wandeln.

@endnode

## ##############################################################################
@node "Objc" "CF-Lib: Objc"
@{U}Objektmanipulation                                                  CF-Lib@{0}

@alabel get_obtype
   int  get_obtype(OBJECT *tree, int obj, short *ud);
         Gibt den Objekttyp zurÅck. Bei umgewandelten Objekten
         (USERDEFs) wird jeweils der Basistyp zurÅckgegeben und
         <ud> auf 1 gesetzt (nur, falls <ud> != NULL).

@alabel get_obspec
@alabel set_obspec
   long get_obspec(OBJECT *tree, int obj);
   void set_obspec(OBJECT *tree, int obj, long spec)
         Abfragen/éndern der ob_spec.
         Bei umgewandelten Objekten (USERDEFs) wird der Original-
         wert zurÅckgegeben/geÑndert.

@alabel get_string
@alabel set_string
   void set_string(OBJECT *tree, int obj, char *text);
   void get_string(OBJECT *tree, int obj, char *text);
         Objekttext setzen/auslesen. Funkt fÅr G_BUTTON, G_STRING, G_TITLE,
         G_CICON, G_ICON, G_TEXT, G_BOXTEXT, G_FTEXT, G_FBOXTEXT.

@alabel set_int
@alabel get_int
@alabel set_long
@alabel get_long
@alabel set_ulong
   void set_int(OBJECT *tree, int obj, int i);
   int  get_int(OBJECT *tree, int obj);
   void set_long(OBJECT *tree, int obj, long l);
   long get_long(OBJECT *tree, int obj);
   void set_ulong(OBJECT *tree, int obj, unsigned long l);
         Zahl in Text-Objekt setzen/lesen.

@alabel set_state
@alabel get_state
   void set_state(OBJECT *tree, int obj, int state, int set);
   int get_state(OBJECT *tree, int obj, int state);
         Objektstatus setzen (set = 1) oder lîschen (set = 0)
         bzw. abfragen.

@alabel tree_state
   void tree_state(OBJECT *tree, int start_obj, int state, int set);
         Bei allen Elementen eines Sub-Baums den Status Ñndern
         (nicht rekursiv!!)

@alabel set_flag
@alabel get_flag
   void set_flag(OBJECT *tree, int obj, int flag, int set);
   int get_flag(OBJECT *tree, int obj, int flag);
         Objektflag setzen (set = 1) oder lîschen (set = 0)
         bzw. abfragen.

@alabel find_flag
   int  find_flag(OBJECT *tree, int flag);
         Sucht das erste Object im Baum, bei dem <flag> gesetzt ist.

@alabel get_objframe
   void get_objframe(OBJECT *tree, int obj, GRECT *r);
         Ermittelt die absoluten Ausmaûe eines Objekts. Beachtet Rahmen,
         3D und alle anderen Flags.

@alabel readrw_obj
   void redraw_obj(OBJECT *tree, int obj);
         Objekt neu zeichnen.

@endnode

## ##############################################################################
@node "Popup" "CF-Lib: Popup"
@{U}Popupverwaltung                                                     CF-Lib@{0}

Neben in der Resource definierte Popups kann man mit den Funktionen auch
dynamisch zur Laufzeit Popups erzeugen.

@alabel POPUP
   typedef struct _popup
   {
      OBJECT   *tree;      /* der Objektbaum */
      int      max_item;   /* maximal mîgliche Anzahl */
      int      akt_item;   /* aktuelle Anzahl */
      int      item_len;   /* LÑnge eines Eintrages */
   } POPUP;
         Kontrollstruktur fÅr die dynamischen Popups.

@alabel create_popup
   int create_popup(POPUP *p, int anz, int maxlen, char *item);
         Neues Popup anlegen.
            p        die Popup Variable
            anz      die Anzahl der maximal mîglichen EintrÑge
            maxlen   maximale LÑnge der EintrÑge. Wird -1 Åbergeben,
                     wird strlen(item) als maximale LÑnge angesehen.
            item     der erste Eintrag, der die LÑnge fÅr alle
                     weiteren festlegt!!
         Ein RÅckgabewert von 0 zeigt an, daû der Objekt-Speicher
         nicht angefordert werden konnte.

@alabel free_popup
   int free_popup(POPUP *p);
         Gibt den Speicher wieder frei.

@alabel append_popup
   int append_popup(POPUP *p, char *item);
         Eintrag am Ende anhÑngen.
         p        das Popup
         item     Eintrag, der am Ende angehÑngt werden soll. Wenn ein
                  Eintrag aus '-' besteht, wird er 'disabled' angezeigt.
         Ein RÅckgabewert von 0 zeigt an, daû der Objekt-Speicher
         nicht angefordert werden konnte.

@alabel do_popup
   int do_popup(POPUP *p, int button);
         Popup auf den Bildschirm bringen und ausfÅhren. Es erscheint
         an der aktuellen Mausposition.
         RÅckgabe:
            Der ausgewÑhlte Eintrag (beginnend bei 1) oder null.

@alabel cf_menu_popup
   int cf_menu_popup(MENU *m1, int x, int y, MENU *m2, int button, int off);
         Kopie von menu_popup(), die enweder menu_popup() aufruft oder
         diesen Call emuliert.
         Die Emulation unterstÅtzt keine scrollende MenÅs!!
         ZusÑtzliche Parameter:
         Falls <button> = 0 und das System menu_popup() hat, wird dieses
         benutzt. Ist <button> = 1/2 (linke/rechte Maustaste), wird das
         Popup selbst verwaltet. Es geht dann z.B. sofort auf (nicht wie
         bei menu_popup() erst beim Loslassen der Taste).
         <off> gibt den Offset zwischen Root-Objekt (Rahmen) und dem
         ersten Popup-String an (i.d.R. ist offset 0, bei einem Farb-Popup
         aber z.B. nicht).

@alabel handle_popup
   int handle_popup(OBJECT *dial, int dial_obj, OBJECT *pop, int pop_obj,
                     int mode);
         Hi-Level Popupverwaltung fÅr Dialoge.
            dial     der Dialog, in dem das Popup angeklickt wurde
            dial_obj Nummer des Objekts im Dialog
            pop      der Baum, in dem das Popup enthalten ist
            pop_obj  Nummer des Popups im Baum
            mode     Aktion, die ausgefÅhrt werden soll:
                     POP_OPEN (1)   Popup îffnen
                     POP_CYCLE (2)  NÑchsten Eintrag selektieren

         Infos zur Popup-Gestaltung in der RSC gibts @{hier link "Spezielle RSC-Elemente"}.

@endnode

## ##############################################################################
@node "Scrap" "CF-Lib: Scrap"
@{U}Scrap                                                               CF-Lib@{0}

Simple Klemmbrettverwaltung (alle Aktionen auf scrap.txt).

   int get_scrapdir(char *scrap);
   void scrap_clear(void);
   char *scrap_rtxt(char *buf, long *len, long maxlen);
   void scrap_wtxt(char *buf);

@endnode

## ##############################################################################
@node "Userdef" "CF-Lib: Userdef"
@{U}Userdef-Verwaltung                                                  CF-LIB@{0}

Die CF-Lib emuliert die erweiterten Objekt-Typen von MagiC. Emuliert werden
Radio- und Checkbuttons, Gruppenrahmen, öberschift sowie Shortscuts zur
Tastaturauslîsung der Objekte.
ZusÑtzlich zu den MagiC-Objekten gibt es noch Gruppenrahmen und öberschrift
mit kleinem Systemfont. Die kleine Schrift wird verwendet, wenn zu den
normalen MagiC-Flags noch der Status CHECKED aktiviert wird.

@alabel fix_dial
   void fix_dial(OBJECT *tree);
         Wandelt die Objekte eines Baumes ggf. in USERDEFs um.

@alabel fix_menu
   void fix_menu(OBJECT *tree);
         Ersetzt die '--' in MenÅs durch echte Linie. Kann auch fÅr die
         Trenner in Popups benutzt werden.

@alabel fix_popup
   void fix_popup(OBJECT *tree, int thin_line);
         Alternative zu fix_menu().
         Unter MagiC werden die EintrÑge in G_SHORTCUT gewandelt.
         Auûerdem ist es mîglich, eine dÅnnere Linie als Trennlinien,
         als sie bei normalen MenÅs zum Einsatz kommen, zu erhalten.

@index "Eigene USERDEFs"
ACHTUNG: Wenn ein Programm neben den von der CF-Lib verwalteten auch
         noch eigene USERDEFs verwendet, funktioniert get_obtype() fÅr
         diese nicht unbedingt korrekt!
         get_obtype() geht davon aus, daû der alte Objekttyp im oberen
         Byte von ob_type liegt (im unteren liegt G_USERDEF). Ist dem
         nicht so, liefert get_obtype() falsche Werte zurÅck und alle
         Teile der CF-Lib, die auf diese Funktion aufbauen, werden sich
         nicht korrekt verhalten!

@endnode

## ##############################################################################
@node "Vdi" "CF-Lib: Vdi"
@{U}NÅtzliches rumd um das VDI                                          CF-Lib@{0}

@alabel open_vwork
   int open_vwork(int *w_out);
         Virtuelle WS îffnen. öbergeben werden muû das 57 int groûe
         work_out Array.

@alabel set_clipping
   void set_clipping(int handle, int x, int y, int w, int h, int on);
         Clipping an- bzw. ausschalten.

@alabel height2pts
   int height2pts(int handle, int f_id, int f_height);
         Ermittelt aus einer Pixel-Hîhe die zugehîrige Point-Hîhe.

@endnode

## ##############################################################################
@node "Wdial" "CF-Lib: Wdial"
@{U}Fensterdialoge                                                      CF-Lib@{0}

Mit diesen Funkionen sind unmodale Fensterdialge mîglich.
Die geîffneten Dialoge laufen parallel zu den anderen Fenstern der
Applikation.

   #define WD_CLOSER
      exit_obj fÅr Closer, fall kein UNDO-Obj vorhanden ist.

   #define WD_OPEN
   #define WD_ICON
   #define WD_SHADE
      Zustand des Fenster (wd->mode).

@alabel WDIAL_OCB
@alabel WDIAL_XCB
   typedef void (* WDIAL_OCB )(WDIALOG *dial);
   typedef int  (* WDIAL_XCB )(WDIALOG *dial, int exit_obj);

   #define WOCB_NULL
   #define WXCB_NULL
         NULL-Pointer fÅr den Fall, daû man kein Callback einklinken
         will.

@alabel WDIALOG
   typedef struct _wdial
   {
      struct _wdial  *next;

      OBJECT      *tree;           /* Objektbaum */
      OBJECT      *icon;           /* Icon fÅr Iconify */
      int         mode;            /* aktueller Status */
      int         win_handle;      /* Fensterhandle */
      char        win_name[80];    /* Fenstertitel */
      int         win_kind;        /* Elemente */
      GRECT       work;            /* Fenstergrîûe */
      int         title_obj;       /* Objektnummer des Titelobjektes */
      int         cancel_obj;      /*       "      des Abbruchbuttons */
      int         delta_y;         /* Offset bis zum Titelobjekt */
      int         edit_idx,        /* Objektnummern fÅr die Editfelder */
                  next_obj,
                  edit_obj;
      WDIAL_OCB   open_cb;
      WDIAL_XCB   exit_cb;
   } WDIALOG;


@alabel create_wdial
   WDIALOG *create_wdial(OBJECT *tree, OBJECT *icon, int edit_obj,
                                 WDIAL_OCB open_cb, WDIAL_XCB exit_cb);
         Neuen Fensterdialog anlegen. Dazu wird der Objektbaum, der
         Baum fÅr das Icon-Fenster, das erste Editfeld (oder 0) sowie
         zwei Callbacks (oder NULL) Åbergeben.
         <open_cb> wird aufgerufen, bevor das Fenster geîffnet wird.
         <exit_cb> wird fÅr Exit-Objekte aufgerufen.
         Der Dialog wird geschlossen (aber nicht gelîscht), sobald der
         Exit-Callback TRUE zurÅckgeliefert.
         Wurde der Closer betÑtigt, wird der Exit-Callback mit dem
         Index des UNDO-Buttons benutzt. Ist kein UNDO-Button vorhanden,
         wird WD_CLOSER (s.o.) geliefert.
         Der Exit-Button wird beim Close deselektiert!

@alabel delete_wdial
   void delete_wdial(WDIALOG *wd);
         Fensterdialog wieder abmelden.

@alabel open_wdial
   void open_wdial(WDIALOG *wd, int pos_x, int pos_y);
         Dialog an der Åbergebenen Position geîffnet. Bei (-1,-1) wird
         er zentriert.

@alabel close_wdial
   void close_wdial(WDIALOG *wd);
         Schlieût das Fenster.

@alabel redraw_wdobj
   void redraw_wdobj(WDIALOG *wd, int obj);
         Zeichnet Objekt neu.

@alabel redraw_wdicon
   void redraw_wdicon(WDIALOG *wd, int obj);
         Zeichnet den iconifizierten Dialog neu.

@alabel change_wdedit
   void change_wdedit(WDIALOG *wd, int new);
         Sollte man einmal aufrufen, nachdem man man den Status von Edit-
         feldern in offenen Dialogen geÑndert (z.B. DISABLED) hat, damit
         die Cursor-Verwaltung sich ein neues gÅltiges Editfeld sucht bzw.
         den Cursor korrekt versteckt.

@alabel message_wdial
@alabel click_wdial
@alabel key_wdial
   int message_wdial(int *msg);
   int click_wdial(int clicks, int x, int y, int kshift, int mbutton);
   int key_wdial(int kreturn, int kstate);
         Diese drei Funktionen mÅûen von der der Haupt-Eventschleife der
         Applikation bei den entsprechenden Events aufgerufen werden.
         Wurde ein Event verarbeitet, wird 1 zurÅckgeliefert, sonst 0.

@endnode


## ##############################################################################
@node "RSC-Gestaltung" "Tips zur RSC-Gestaltung"
@{U}Tips zur RSC-Gestaltung                                             CF-Lib@{0}

   @{"Erweiterte Objekttypen von MagiC" link "MagiC-Objekttypen"}

   @{"Aufbau einiger besonderer RSC-Elemente" link "Spezielle RSC-Elemente"}

   Sondertasten-Belegung

 @{U}FÅr Lese-Faule:@{0}
   Im ExtObjFix.prg fÅr InterFace ist eine Kurzhilfe vorhanden, in
   der die wichtigsten Objekttypen aufgelistet sind.
   An diese Hilfe gelangt man, wenn man in den InterFace-Objekt-
   editoren den entsprechenden Button bzw. die HELP-Taste auslîst!

@endnode


@node "MagiC-Objekttypen" "Erweiterte Objekttypen von MagiC"
@{U}Erweiterte Objekttypen von MagiC                                    CF-Lib@{0}
@autorefoff

MagiC bietet neben den standard GEM-Objekten einige Erweiterungen.
Dabei handelt es sich um jeweils einen Standardtyp mit einem besonderen
Status bzw. Flag.
Falls das Objekt einen Shortcut erlaubt, wird dessen Position Åber eine
4bit Zahl in den Status-Bits 8 - 11 festgelegt.

   @{U}Titel (unterstrichener Text)@{0}
         Basistyp:      G_STRING
         Status:        WHITEBACK sowie Bits 8 - 15
         Sonstiges:     Es wird empfolen, die Objekthîhe um zwei bis
                        drei Pixel zu vergîûern.

   @{U}Gruppenrahmen@{0}
         Basistyp:      G_BUTTON
         Status:        WHITEBACK sowie Bits 9 - 15
         Sonstiges:     CF-Lib-Erweiterung: Bei Status CHECKED wird
                        der Text im kleinen Systemfont gesetzt.

   @{U}EXIT-Button@{0}
         Basistyp:      G_BUTTON
         Status:        EXIT, 3D-Activator
                        mit Shortcut: WHITEBACK, Position Åber Bits 8 - 11.

   @{U}Kreuz-Button@{0}
         Basistyp:      G_BUTTON
         Status:        WHITEBACK, 3D-Background
                        mit Shortcut: Bit 15, Position Åber Bits 8 - 11.
                        ohne Shortcut: Bits 8 - 15

   @{U}Radio-Button@{0}
         Basistyp:      G_BUTTON
         Status:        RADIOBUTTON, WHITEBACK, 3D-Background
                        mit Shortcut: Bit 15, Position Åber Bits 8 - 11.
                        ohne Shortcut: Bits 8 - 15

   @{U}tast. String@{0}
         Basistyp:      G_STRING
         Status:        WHITEBACK, Shortcut-Position Åber Bits 8 - 11.

   @{U}Edit-Objekt@{0}
         Basistyp:      G_FTEXT
         Status:        EDITABLE, 3D-Background
         Sonstiges:     Rand auûen 2 Pixel
                        Wird ab 16 Farben eingesunken, in Monochrom
                        umrahmt gezeichnet.
                        Durch den Rand sollte zwischen zwei Åber-
                        einanderliegenden Edit-Objekten 1,5 Zeilen
                        Platz gelassen werden, da sonst die Rahmen
                        kollidieren.
@autorefon

@endnode

@node "Spezielle RSC-Elemente"
@{U}Aufbau spezieller RSC-Elemente                                     CF-Lib@{0}


@{U}Popups@{0}
@autorefoff

Die Routine handle_popup() setzt einen der beiden folgenden Popup-
Strukturen im Dialog voraus:

              String: [Popup-Box]
     oder
              String: [z.B. Editfeld] []

Bei [Popup-Box] handelt es sich um einen BOXTEXT (SHADOWED,
TOUCHEXIT, 3D-Background), der die LÑnger der Strings im Popup plus
einem Blank vorne und hinten haben sollte. handle_popup() lieût den
Text aus diesem Objekt aus und positioniert das Popup entsprechend.
Nach Auswahl eines Eintrags wird dessen Text automatisch in die Popup-
Box eingetragen.

Bei [] handelt es sich um ein BOXCHAR (SHADOWED, TOUCHEXIT, 3D-
Background), an dem das Popup rechtsbÅndig nach unten aufgeht. Da die
CF-Lib nicht wissen kann, in welches Objekt der Text des ausgewÑhlten
Eintrags geschrieben werden soll, muû man das bei diesem Popup-Typ
selbst erledigen!

Bei <String> kînnte es sich um ein tastaturbedienbaren STRING handeln,
Åber den das Popup per Tastatur gesteuert wird. Die Dialog-Routinen
mÅûte dann handle_popup() mit Modus POP_CYCLE aufrufen, um den nÑchsten
Eintrag einzustellen. Auch diese Funktion funktioniert nur mit dem ersten
Popup-Typ, da nur dort die CF-Lib durch den Text in der Popup-Box weiû,
welches der nÑchste Eintrag ist.

Das eigentliche Popup sollte aus einer BOX (SHADOWED, 3D-Background)
bestehen, in der die EintrÑge als STRING (SELECTABEL, !DISABLED)
realisiert werden. Trennlinien kînnen durch disabled'te '--'-EintrÑge
erzeugt werden. Damit die '--' durch eine richtige Linie ersetzt wird,
muû fÅr das Popup dial_fix() aufgerufen werden.

@autorefon

@endnode

@node "Sondertasten-Belegung"
@{U}Sondertasten in Dialogen                                           CF-Lib@{0}

Einige Sondertasten sind in den Dialogen der CF-Lib mit Funktionen
belegt:

   - Ein Exit-Button bei dem das Flag Bit 11 gesetzt ist, kann mit
     UNDO ausgelîst werden.

   - Ein Exit-Button bei dem das Flag Bit 12 gesetzt ist, kann mit
     HELP ausgelîst werden.

   - In Alertboxen kînnen die Buttons mit F1 bis F3 ausgelîst
     werden (wie in MagiC).

   - Die INSERT-Taste innerhalb eines Editfelds îffnet die ASCII-
     Tabelle.

   - öber ^X, ^C und ^V kann der Text vom GEM-Klemmbrett in Edit-
     feldern verarbeitet werden.

   - Mit TAB bzw. Shift-TAB kann zum nÑchsten bzw. vorherigen
     Editfeld gesprungen werden. Vom Letzten wird wieder zum
     Ersten gesprungen und umgekehrt.

@endnode

## ##############################################################################
@node "Programmliste" "CF-Lib: Programmliste"
@{U}Programmliste                                                       CF-Lib@{0}

Hier eine Liste der Programme, die die CF-Lib benutzen:

  @{U}Programm       Autor              Programm-Version@{0}

   gemgs         CF                    ab 1.0

   GEM-Setup     Joachim Fornallaz     ab 1.20

   HD-Driver     Uwe Seimet            ab 7.70

   qed           CF                    ab 4.5

   TosWin2       CF                    ab 2.2


@endnode
